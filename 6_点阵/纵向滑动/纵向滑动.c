#include<reg51.h>
#define uint unsigned int
#define uchar unsigned char


unsigned char code kong0[32]={0};//首尾相同，以达到连续滑动的效果

unsigned char code xie[32]={0x01,0x08,0x42,0x08,0x27,0x88,0x24,0x88,0x07,0xBE,0x04,0x88,0xE7,0x88,0x24,0xC8,
0x24,0xA8,0x2F,0xA8,0x21,0x88,0x2A,0x88,0x34,0x88,0x28,0x88,0x02,0xA8,0x01,0x10};

unsigned char code yu[32]={0x00,0x00,0x7F,0xFC,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x3F,0xF8,
0x01,0x00,0x01,0x00,0x01,0x20,0x01,0x10,0x01,0x10,0x01,0x00,0xFF,0xFE,0x00,0x00};
		
unsigned char code shen[32]={0x08,0x40,0x08,0x40,0x08,0x40,0x17,0xFC,0x14,0x44,0x34,0x44,0x34,0x44,0x57,0xFC,
0x94,0x44,0x14,0x44,0x14,0x44,0x17,0xFC,0x14,0x44,0x10,0x40,0x10,0x40,0x10,0x40};				
								
unsigned char code kong1[32]={0};

unsigned char code hang[16][2]={{0x80,0x00},{0x40,0x00},{0x20,0x00},{0x10,0x00},{0x08,0x00},{0x04,0x00},{0x02,0x00},{0x01,0x00},
							   {0x00,0x80},{0x00,0x40},{0x00,0x20},{0x00,0x10},{0x00,0x08},{0x00,0x04},{0x00,0x02},{0x00,0x01}};
							 //{高位(上面的),低位(下面的)}

unsigned char code *st[]={xie,yu,shen};



sbit sck=P3^6;
sbit lck=P3^5;
sbit sdi=P3^4;


void send(int dat0,int dat1,int dat2,int dat3);
void upch();
void downch();
				  
void main()
{

    
     while(1)
     {
	 downch();

	 upch();
	 
	
 	
    }
}



void upch()
{

    char i,k,n,w=0;
 while(w<=1)//会从第二个字加到第三个字
 {
   
	for(k=0;k<16;k++)//移屏
	{
	n=3;
	 if(k==15&&w==1) n=10;
	  
	  while(n--)//反复 刷几次，就可以减慢速度
	  {
	   
       for(i=0;i<16;i++)//刷屏
	   {
	    send(~st[w][(i+k)*2+1],~st[w][(i+k)*2],hang[i][1],hang[i][0]);
	   }
	  }
	} 
	 w++;
 }
}


void downch()
{

   char i,k,n,w=1;
  while(w>=0)//会从第二个字加到第三个字
  {
	for(k=15;k>=0;k--)//移屏
	{
	  n=3;
	  if(k==0&&w==0) n=10;
	  
	  while(n--)//反复 刷几次，就可以减慢速度
	  {
       for(i=0;i<16;i++)//刷屏
	   {
	    send(~st[w][(i+k)*2+1],~st[w][(i+k)*2],hang[i][1],hang[i][0]);
	   }
	  }
	} 
   w--;
  }
}



void send(int dat0,int dat1,int dat2,int dat3)
{

  unsigned char i;
  sck=1;//上升沿 移位
  lck=1;//上升沿 输出
  //第一段数据
  for(i=0;i<8;i++)
  {
    sck=0;
	sdi=dat0&0x01;
	dat0>>=1;
	
	sck=1; 	
  
  }
 
  //第二段数据
  for(i=0;i<8;i++)
  {
    sck=0;
	sdi=dat1&0x01;
	dat1>>=1;
	 
	sck=1;	

  }
   
   //第三段数据
  for(i=0;i<8;i++)
  { 
    sck=0;
    sdi=dat2&0x01;
	dat2>>=1;
   
	sck=1;	

  }
     
   //第四段数据
  for(i=0;i<8;i++)
  {
    sck=0;
	sdi=dat3&0x01;
	dat3>>=1;
	
	sck=1;	
  }

  //并口输出
   lck=0;
   lck=1;
    

}





