#include<reg51.h>
#define uint unsigned int
#define uchar unsigned char


unsigned char code kong0[32]={0};//首尾相同，以达到连续滑动的效果
//先左右翻转，再旋转90° 或者 横向字需要旋转90°再上下翻转
unsigned char code landxie[32]={0x02,0x00,0x42,0x00,0x33,0xFC,0x00,0x08,0x00,0x54,0x3F,0xC8,0x6A,0x52,0xAA,0x61,
0x3F,0xFE,0x01,0x00,0x08,0xC2,0x08,0x01,0xFF,0xFE,0x08,0x00,0x08,0x00,0x00,0x00};
//横向Landscape		 纵向Portrait	
unsigned char code landyu[32]={0x00,0x02,0x40,0x02,0x41,0x02,0x41,0x02,0x41,0x02,0x41,0x02,0x41,0x02,0x7F,0xFE,
0x41,0x02,0x41,0x02,0x41,0x22,0x41,0x1A,0x41,0x02,0x40,0x02,0x00,0x02,0x00,0x00};

unsigned char code landshen[32]={0x00,0x80,0x01,0x00,0x06,0x00,0x1F,0xFF,0xE0,0x00,0x1F,0xF8,0x11,0x10,0x11,0x10,
0x11,0x10,0xFF,0xFF,0x11,0x10,0x11,0x10,0x11,0x10,0x1F,0xF8,0x00,0x00,0x00,0x00};


unsigned char code kong1[32]={0};

unsigned char code hang[16][2]={{0x80,0x00},{0x40,0x00},{0x20,0x00},{0x10,0x00},{0x08,0x00},{0x04,0x00},{0x02,0x00},{0x01,0x00},
							   {0x00,0x80},{0x00,0x40},{0x00,0x20},{0x00,0x10},{0x00,0x08},{0x00,0x04},{0x00,0x02},{0x00,0x01}};
							 //{高位(上面的),低位(下面的)}

unsigned char code *st[]={landxie,landyu,landshen,kong0};



sbit sck=P3^6;
sbit lck=P3^5;
sbit sdi=P3^4;


void send(int dat0,int dat1,int dat2,int dat3);
void rightch();
void leftch();


void main()
{

  while(1)
  {
  
   
   rightch(); 
   leftch();
  }
}


void rightch()
{
  char i,k,n,w=1;
  while(w>=0)
  {
	for(k=15;k>=0;k--)//移屏
	{
	  n=3;
	  if(w==0&&k==0 ) n=10;
	  
	  while(n--)//反复 刷几次，就可以减慢速度
	  {
       for(i=0;i<16;i++)//刷屏
	   {
	    send(~hang[i][1],~hang[i][0],st[w][(i+k)*2+1],st[w][(i+k)*2]);
	   }
	  }
	} 
   w--;
  }

}

void leftch()
{
  char i,k,n,w=0;
  while(w<=1)
  {
	for(k=0;k<16;k++)//移屏
	{
	  n=3;
	  if(w==1&&k==15) n=10;
	  while(n--)//反复 刷几次，就可以减慢速度
	  {
       for(i=0;i<16;i++)//刷屏
	   {
	    send(~hang[i][1],~hang[i][0],st[w][(i+k)*2+1],st[w][(i+k)*2]);
	   }
	  }
	} 
   w++;
  }

}







void send(int dat0,int dat1,int dat2,int dat3)
{

  unsigned char i;
  sck=1;//上升沿 移位
  lck=1;//上升沿 输出
  //第一段数据
  for(i=0;i<8;i++)
  {
    sck=0;
	sdi=dat0&0x01;
	dat0>>=1;
	
	sck=1; 	
  
  }
 
  //第二段数据
  for(i=0;i<8;i++)
  {
    sck=0;
	sdi=dat1&0x01;
	dat1>>=1;
	 
	sck=1;	

  }
   
   //第三段数据
  for(i=0;i<8;i++)
  { 
    sck=0;
    sdi=dat2&0x01;
	dat2>>=1;
   
	sck=1;	

  }
     
   //第四段数据
  for(i=0;i<8;i++)
  {
    sck=0;
	sdi=dat3&0x01;
	dat3>>=1;
	
	sck=1;	
  }

  //并口输出
   lck=0;
   lck=1;
    

}





